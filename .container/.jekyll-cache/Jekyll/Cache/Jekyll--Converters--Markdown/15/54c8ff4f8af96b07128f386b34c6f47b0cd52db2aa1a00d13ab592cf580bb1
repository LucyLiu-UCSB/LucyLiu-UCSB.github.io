I"ò0<h2 id="question">Question</h2>

<p>Given a list of number, how many inversion pairs are there? If the list is [1, 3, 5, 2, 4, 6], there are three inversions: (3, 2), (3, 4), (3, 6). A brute force method would be using two loops, resulting in an algorithm with running time \( O(n^2) \), where \(n\) is the length of the list.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">bruteForceCount</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">arr</span> <span class="p">(</span><span class="n">j</span><span class="p">):</span> <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">count</span> 
</pre></td></tr></tbody></table></code></pre></div></div>
<h2 id="divide-and-conquer">Divide and Conquer</h2>
<p>Can we do better?</p>

<p>The Merge sort algorithm using the Divide and Conquer technique reduces the running time from \(O(n^2)\) to \(n\log n\). From my understanding, the magic happens at the cleaning up step. With two length \(m\) <strong>sorted</strong> sublists, to form the original list, the running time is \(O(m)\) instead of \(O(m^2)\). Combined with the recursive tree structure, the depth of the tree is \(\log_2 n\) and running time for each level, \(i = 1, \ldots, \log_2 n\),   is \(O(n)\). Finally, the merge sort algorithm has running time \(O(n\log n)\).</p>

<p>To count the inversion, the subquestion is to count the inversions in the left sublist and right sublist. The cleanup work is counting the number of split inversions, i.e, for inversion pair \((a, b)\), \(a \in\) left sublist and \(b \in\) right sublist. With two sorted length \(m\) sublists, the running time of the clean up work is \(O(m)\). Hence, the counting inversion algorithm has running time \(O(n\log n)\).</p>

<h2 id="statistical-view">Statistical View</h2>

<p>Where can we use this the algorithm? The inversion number can be used as a measurement of dissimilarity. For instance, if two customers give their ranking for 3 fruits, the number of inversions in rank lists will measure how their preference is different from each other.</p>

<p>Suppose that customer I ranks apple = 1, orange = 2, grape = 3. And customer II ranks orange = 1, grape = 2 and apple = 3. Then we count inversion of list [3, 1, 2] as 2. If they give the same rank list, the number of inversions is 0.</p>

<p>A nature question is if let two independent subjects rank \(n\) items, what is the average numebr of inversions. The answer is \(n(n-1)/4\). The following proof utilizes indicator function:
    \[I_{ij} = 1, \text{ if }  i &lt; j \text{ and } X[i] &gt; X[j].\]
    Then number of inversions in the list \(\mathbf{X}\) is \(\sum_i\sum_j I_{ij}\).
\[ \mathbf{E}\left(\sum_{i=1}^n\sum_{j=1}^n I_{ij}\right) = \sum_{i=1}^n\sum_{j=1}^n \mathbf{E}(I_{ij}) 
= \sum_{i=1}^n\sum_{j = i + 1}^n P(X[i] &gt; X[j]) 
= \sum_{i=1}^n \sum_{j = i + 1}^n \frac{1}{2} 
= [(n-1)+\ldots+1]\times \frac{1}{2} = \frac{n(n-1)}{4},\]
where the second equlity is due to the definition of expection of discrete random variable, and the reason for \(P(X[i] &gt; X[j]) = 1/2\) is that when randomly picking up any two elements from the list, the first is greater than the second with probability 1/2.</p>

<h2 id="python-code">Python Code</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">mergeSortInversion</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    
    <span class="c1"># define base case
</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># define two sublist
</span>        <span class="n">left</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">):]</span>
        
        <span class="c1"># recursion, return left and right are the sorted sublists
</span>        <span class="n">left</span><span class="p">,</span> <span class="n">leftCount</span> <span class="o">=</span> <span class="n">mergeSortInversion</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span><span class="p">,</span> <span class="n">rightCount</span> <span class="o">=</span> <span class="n">mergeSortInversion</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
        

        <span class="c1"># the sorted list
</span>        <span class="n">lsorted</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># index of left sublist
</span>        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># index of right sublist
</span>        <span class="n">inversions</span> <span class="o">=</span> <span class="n">leftCount</span> <span class="o">+</span> <span class="n">rightCount</span>
        
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="c1"># not an inversion
</span>                <span class="n">lsorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># an inversion case
</span>                <span class="n">lsorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">inversions</span> <span class="o">=</span> <span class="n">inversions</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span>
         
        <span class="c1"># conbime the remaining sublist, note only one of left[i:] and right[j:] is not null
</span>        <span class="n">lsorted</span> <span class="o">=</span> <span class="n">lsorted</span> <span class="o">+</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
        <span class="n">lsorted</span> <span class="o">=</span> <span class="n">lsorted</span> <span class="o">+</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">:]</span>

    <span class="k">return</span> <span class="n">lsorted</span><span class="p">,</span> <span class="n">inversions</span> 
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="simulation">Simulation</h2>
<p>Now we run a small simulation to estimate the average number of inversions in a length \(n\) list.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">mlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span>
<span class="n">totalCountlist</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mlist</span><span class="p">:</span>
    <span class="n">totalCount</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">arrsot</span><span class="p">,</span> <span class="n">cot</span> <span class="o">=</span> <span class="n">mergeSortInversion</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">totalCount</span> <span class="o">=</span> <span class="n">totalCount</span> <span class="o">+</span> <span class="n">cot</span>
        <span class="n">aveCount</span> <span class="o">=</span> <span class="n">totalCount</span><span class="o">/</span><span class="mi">1000</span>
    <span class="n">totalCountlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aveCount</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Average number of inversions as a function of length \(n\):
    <img src="/assets/img/sample/inversion_11222019.png" alt="inversion_11222019" /></p>
:ET